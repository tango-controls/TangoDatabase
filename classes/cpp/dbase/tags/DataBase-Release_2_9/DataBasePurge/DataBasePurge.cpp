static const char *RcsId = "$Header$";
//+=============================================================================
//
// file :         DataBasePurge.cpp
//
// description :  C++ source for the DataBasePurge and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                DataBasePurge are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author$
//
// $Revision$
//
// $Log$
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The folowing table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//
//===================================================================


#include <tango.h>
#include <DataBasePurge.h>
#include <DataBasePurgeClass.h>
#include <PurgeThread.h>

namespace DataBasePurge_ns
{

//+----------------------------------------------------------------------------
//
// method : 		DataBasePurge::DataBasePurge(string &s)
// 
// description : 	constructor for simulated DataBasePurge
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
DataBasePurge::DataBasePurge(Tango::DeviceClass *cl,string &s)
:Tango::Device_3Impl(cl,s.c_str())
{
	init_device();
}

DataBasePurge::DataBasePurge(Tango::DeviceClass *cl,const char *s)
:Tango::Device_3Impl(cl,s)
{
	init_device();
}

DataBasePurge::DataBasePurge(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_3Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		DataBasePurge::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void DataBasePurge::delete_device()
{
	//	Delete device's allocated object
	thread_alive = false;
	void *arg;
	purgeThread->join(&arg);
	delete purgeThread;
	mysql_close(&mysql);	
}

//+----------------------------------------------------------------------------
//
// method : 		DataBasePurge::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void DataBasePurge::init_device()
{
	cout << "DataBasePurge::DataBasePurge() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	
	// Initialise MySQL
	//--------------------------------------------
	char *database = (char *)"tango";
	char *mysql_user = (char *)"root";
	char *mysql_password = (char *)"";

	mysql_init(&mysql);

	if (getenv("MYSQL_USER") != NULL)
	{
		mysql_user = getenv("MYSQL_USER");
	}
	if (getenv("MYSQL_PASSWORD") != NULL)
	{
		mysql_password = getenv("MYSQL_PASSWORD");
	}
	DEBUG_STREAM << "DataBase::DataBase() mysql database user =  " << mysql_user 
	             << " , password = " << mysql_password << endl;

	if (!mysql_real_connect(&mysql, "localhost", mysql_user, mysql_password, database, 0, NULL, 0))
	{
		TangoSys_MemStream out_stream;
		out_stream << "Failed to connect to TANGO database (error = "
         		   << mysql_error(&mysql) << ")" << ends;
		Tango::Except::throw_exception(
					(const char *)"CANNOT_CONNECT_MYSQL",
					out_stream.str(),
					(const char *)"DataBase::init_device()");
	}
	
	// Start the purge thread
	//--------------------------------------------
	thread_alive = true;
	purge_in_progress = false;
	purgeThread = new PurgeThread(this);

	set_state(Tango::ON);
	set_status("Device is OK");
	
}

//+----------------------------------------------------------------------------
//
// method : 		DataBase::simple_query()
// 
// description : 	Execute a SQL query , ignore the result.
//
//-----------------------------------------------------------------------------
void DataBasePurge::simple_query(string sql_query) {
	
	TangoSys_OMemStream o;
	
	if (mysql_real_query(&mysql, sql_query.c_str(),sql_query.length()) != 0)
	{
	   WARN_STREAM << "DataBasePurge::simple_query() failed to query TANGO database:" << endl;
	   WARN_STREAM << "  query = " << sql_query << endl;
	   WARN_STREAM << " (SQL error=" << mysql_error(&mysql) << ")" << endl;
	   o << "Failed to query TANGO database (error=" << mysql_error(&mysql) << ")";
	   Tango::Except::throw_exception((const char *)"SQL Error",
	                                  o.str(),
					  (const char *)"DataBasePurge::simple_query()");
	}

}

//+----------------------------------------------------------------------------
//
// method : 		DataBase::query()
// 
// description : 	Execute a SQL query and return the result.
//
//-----------------------------------------------------------------------------
MYSQL_RES *DataBasePurge::query(string sql_query) {

	TangoSys_OMemStream o;
	MYSQL_RES *result;
	
	if (mysql_real_query(&mysql, sql_query.c_str(),sql_query.length()) != 0)
	{
	   WARN_STREAM << "DataBase::query(): failed to query TANGO database:" << endl;
	   WARN_STREAM << "  query = " << sql_query << endl;
	   WARN_STREAM << " (SQL error=" << mysql_error(&mysql) << ")" << endl;
	   o << "Failed to query TANGO database (error=" << mysql_error(&mysql) << ")";
	   Tango::Except::throw_exception((const char *)"SQL Error",
	                                  o.str(),
					  (const char *)"DataBasePurge::query()");
	}

	if ((result = mysql_store_result(&mysql)) == NULL)
	{
	   WARN_STREAM << "DataBase::query(): mysql_store_result() failed  (error=" << mysql_error(&mysql) << ")" << endl;
	   o << "mysql_store_result() failed (error=" << mysql_error(&mysql) << ")";
	   Tango::Except::throw_exception((const char *)"SQL Error",
	                                  o.str(),
					  (const char *)"DataBasePurge::query()");
	}
	
	return result;

}


//+----------------------------------------------------------------------------
//
// method : 		DataBasePurge::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void DataBasePurge::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	if (Tango::Util::instance()->_UseDb==false)
		return;
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("History_depth"));
	dev_prop.push_back(Tango::DbDatum("Purge_Period"));

	//	Call database and extract values
	//--------------------------------------------
	get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	DataBasePurgeClass	*ds_class =
		(static_cast<DataBasePurgeClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize History_depth from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  history_depth;
	//	Try to initialize History_depth from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  history_depth;
	//	And try to extract History_depth value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  history_depth;

	//	Try to initialize Purge_Period from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  purge_Period;
	//	Try to initialize Purge_Period from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  purge_Period;
	//	And try to extract Purge_Period value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  purge_Period;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		DataBasePurge::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void DataBasePurge::always_executed_hook()
{
  char tmp[256];
  
  if(purge_in_progress) {
    set_state(Tango::MOVING);
    sprintf(tmp,"Purge in progress %.1f%%",purge_progress);
    set_status(tmp);
  } else {
    set_state(Tango::ON);    
    set_status("Device is OK");
  }
  	
}

}	//	namespace
